// Copyright 2007-2011 The MathWorks, Inc.
/* Generated by genpubheader from export/include/SimulinkBlock/rtw/blockfunction.hpp. */

#ifdef SUPPORTS_PRAGMA_ONCE
#pragma once
#endif

#ifndef SFUN_BLOCKFUNCTION_HPP
#define SFUN_BLOCKFUNCTION_HPP

#include "../sl_core_block_spec.hpp"
#include "cgir_construct_from_SimulinkBlock.hpp"
#include "block.hpp"

namespace RTW
{
    inline int call_Block_method( Block* pBlock,
                                  void (Block::* pMemFun)())
    {
        try
        {
           
            (pBlock->*pMemFun)();
            return true;
        }
        catch(...)
        {
            setErrorInfoFromActiveException();
            return false;
        }
    }

    inline int call_Block_method( Block* pBlock,
                                  void (Block::* pMemFun)(int, int),
                                  int i,
                                  int j)
    {
        try
        {
           
            (pBlock->*pMemFun)(i, j);
            return true;
        }
        catch(...)
        {
            setErrorInfoFromActiveException();
            return false;
        }
    }

    extern "C"
    {
       
        typedef int (*SFun_BlockFunction)(CodeConstructor*);

        typedef int (*SFun_PortFunction)(CodeConstructor*, int, int);

        static inline int call_cgStart(CodeConstructor* pCodeCtor)
        {
            Block* pBlock = static_cast<Block*>(pCodeCtor);
            return call_Block_method(pBlock, &Block::cgStart);
        }

        static inline int call_cgInitialize(CodeConstructor* pCodeCtor)
        {
            Block* pBlock = static_cast<Block*>(pCodeCtor);
            return call_Block_method(pBlock, &Block::cgInitialize);
        }

        static inline int call_cgOutput(CodeConstructor* pCodeCtor)
        {
            Block* pBlock = static_cast<Block*>(pCodeCtor);
            return call_Block_method(pBlock, &Block::cgOutput);
        }

        static inline int call_cgUpdate(CodeConstructor* pCodeCtor)
        {
            Block* pBlock = static_cast<Block*>(pCodeCtor);
            return call_Block_method(pBlock, &Block::cgUpdate);
        }
        static inline int call_cgTerminate(CodeConstructor* pCodeCtor)
        {
            Block* pBlock = static_cast<Block*>(pCodeCtor);
            return call_Block_method(pBlock, &Block::cgTerminate);
        }
        SL_CORE_BLOCK_EXPORT_CLASS SFun_BlockFunctionTable* SFun_new_BlockFcnTable();
        SL_CORE_BLOCK_EXPORT_CLASS void SFun_delete_BlockFcnTable(SFun_BlockFunctionTable* pFcnTable);

        SL_CORE_BLOCK_EXPORT_CLASS void SFun_set_cgStart          (SFun_BlockFunctionTable* pFcnTable, SFun_BlockFunction pfn_call_cgStart          );
        SL_CORE_BLOCK_EXPORT_CLASS void SFun_set_cgInitialize     (SFun_BlockFunctionTable* pFcnTable, SFun_BlockFunction pfn_call_cgInitialize     );
        SL_CORE_BLOCK_EXPORT_CLASS void SFun_set_cgOutput         (SFun_BlockFunctionTable* pFcnTable, SFun_BlockFunction pfn_call_cgOutput         );
        SL_CORE_BLOCK_EXPORT_CLASS void SFun_set_cgUpdate         (SFun_BlockFunctionTable* pFcnTable, SFun_BlockFunction pfn_call_cgUpdate         );
        SL_CORE_BLOCK_EXPORT_CLASS void SFun_set_cgTerminate      (SFun_BlockFunctionTable* pFcnTable, SFun_BlockFunction pfn_call_cgTerminate      );
    }
   
    template<typename DerivedBlock>
    SFun_BlockFunctionTable* build_BlockFunctionTable(DerivedBlock* = NULL)
    {
       
        SFun_BlockFunctionTable* pFcnTable = SFun_new_BlockFcnTable();
       
        SFun_set_cgStart          ( pFcnTable, &call_cgStart           );
        SFun_set_cgInitialize     ( pFcnTable, &call_cgInitialize      );
        SFun_set_cgOutput         ( pFcnTable, &call_cgOutput          );
        SFun_set_cgUpdate         ( pFcnTable, &call_cgUpdate          );
        SFun_set_cgTerminate      ( pFcnTable, &call_cgTerminate       );
        return pFcnTable;
    }
}

#endif
